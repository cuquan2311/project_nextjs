// 🔍 GIẢI THÍCH: Tại sao {children} vẫn là Server Component

// ✅ HIỂU ĐÚNG: React Element Tree vs Component Tree

// 1. Server Component render trước
// app/layout.tsx (Server Component)
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <ThemeProviders>
          {/* 
            QUAN TRỌNG: {children} ở đây KHÔNG PHẢI là component call!
            Nó là React Element đã được render trên server
          */}
          {children}
        </ThemeProviders>
      </body>
    </html>
  )
}

// 2. Server Component con
// app/page.tsx (Server Component) 
export default function HomePage() {
  console.log('🖥️ Server: This runs on server only!')
  
  return (
    <Container>
      <Typography>Server rendered content</Typography>
      <ServerData />
    </Container>
  )
}

// 3. Client Component wrapper
// components/ThemeProviders.tsx (Client Component)
'use client'
export function ThemeProviders({ children }: { children: React.ReactNode }) {
  console.log('🌐 Client: This runs on client!')
  
  return (
    <NextThemeProvider>
      <MuiThemeWrapper>
        {/* 
          children ở đây là React Element tree đã render,
          KHÔNG PHẢI là component function calls!
        */}
        {children}
      </MuiThemeWrapper>
    </NextThemeProvider>
  )
}

// 🧠 VISUALIZATION: Render Process

/*
BƯỚC 1: Server render
===================
HomePage() được gọi trên server → tạo ra React Element tree:
{
  type: Container,
  props: { 
    children: {
      type: Typography,
      props: { children: "Server rendered content" }
    }
  }
}

BƯỚC 2: Serialization  
====================
React Element tree được serialize thành JSX/HTML

BƯỚC 3: Client hydration
========================
ThemeProviders nhận children là cái React Element tree đã serialize,
KHÔNG phải function calls!
*/

// 🔬 DEMO: Chứng minh với logging

// Server Component
export default function ServerPage() {
  console.log('🖥️ SERVER: HomePage render', new Date()) // Chỉ chạy trên server
  
  return (
    <div>
      <h1>Server Content</h1>
      <ServerComponent />
      <ClientWrapper>
        <AnotherServerComponent />
      </ClientWrapper>
    </div>
  )
}

// Server Component con
function ServerComponent() {
  console.log('🖥️ SERVER: ServerComponent render') // Chỉ chạy trên server
  return <p>I am server rendered</p>
}

// Client Component wrapper
'use client'
function ClientWrapper({ children }: { children: React.ReactNode }) {
  console.log('🌐 CLIENT: ClientWrapper render') // Chạy trên client
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* children này đã render trên server! */}
      {children}
    </div>
  )
}

// Server Component khác
function AnotherServerComponent() {
  console.log('🖥️ SERVER: AnotherServerComponent render') // Chỉ chạy trên server
  return <p>I am also server rendered!</p>
}

// 📊 CONSOLE OUTPUT:
/*
Server Console:
🖥️ SERVER: HomePage render
🖥️ SERVER: ServerComponent render  
🖥️ SERVER: AnotherServerComponent render

Client Console:
🌐 CLIENT: ClientWrapper render
*/

// 🎯 KEY CONCEPTS

// ❌ SAI HIỂU: Nghĩ rằng children được "gọi" trong Client Component
'use client'
function WrongThinking({ children }) {
  // Người ta nghĩ children() được gọi ở đây → thành Client Component
  return <div>{children}</div>
}

// ✅ ĐÚNG: children là React Element tree đã render
'use client' 
function CorrectUnderstanding({ children }: { children: React.ReactNode }) {
  // children ở đây là JSX elements đã được render trên server
  // Không có function call nào xảy ra!
  return <div>{children}</div>
}

// 🔧 TECHNICAL DETAILS

/*
1. REACT ELEMENT vs REACT COMPONENT:
   - Component: function HomePage() { ... } → chạy trên server
   - Element: <HomePage /> hoặc React.createElement() → data structure

2. CHILDREN TRONG PROPS:
   - children không phải function call
   - children là React Element tree (data)
   - Element tree này đã render trên server

3. HYDRATION PROCESS:
   - Server gửi HTML + serialized element tree
   - Client nhận element tree, không re-render Server Components
   - Client chỉ hydrate Client Components
*/

// 🧪 EXPERIMENT: Kiểm tra với component lifecycle

// Server Component với side effects
export default function ExperimentPage() {
  // Side effect chỉ chạy trên server
  const timestamp = new Date().toISOString()
  console.log('🖥️ SERVER ONLY:', timestamp)
  
  return (
    <ClientBoundary>
      <ServerChild timestamp={timestamp} />
    </ClientBoundary>
  )
}

// Client Component boundary
'use client'
function ClientBoundary({ children }: { children: React.ReactNode }) {
  const [mounted, setMounted] = useState(false)
  
  useEffect(() => {
    setMounted(true)
    console.log('🌐 CLIENT: Boundary mounted')
  }, [])
  
  return (
    <div>
      <p>Client boundary (mounted: {String(mounted)})</p>
      {/* children đã render với timestamp từ server */}
      {children}
    </div>
  )
}

// Server Component con
function ServerChild({ timestamp }: { timestamp: string }) {
  console.log('🖥️ SERVER: ServerChild render with:', timestamp)
  
  return (
    <div>
      <p>Server timestamp: {timestamp}</p>
      <p>This timestamp never changes on client interactions!</p>
    </div>
  )
}

// 🎪 REAL-WORLD EXAMPLE: Theme Provider

// Layout (Server)
export default function Layout({ children }) {
  return (
    <html>
      <body>
        {/* 
          Tất cả page components render trên server trước,
          tạo thành element tree, rồi mới pass vào ThemeProvider
        */}
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}

// Theme Provider (Client)  
'use client'
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <div className={theme}>
        {/* 
          children ở đây là element tree đã render trên server:
          - Không có re-render khi theme change
          - Chỉ CSS class thay đổi
          - Performance cao vì không re-execute server logic
        */}
        {children}
      </div>
    </ThemeContext.Provider>
  )
}

// 📝 SUMMARY

/*
TẠI SAO {children} VẪN LÀ SERVER COMPONENT:

1. ✅ Composition over Re-rendering
   - children là data (React Elements), không phải function calls
   - Server Components render thành elements trước khi pass xuống

2. ✅ Serialization Boundary
   - React serialize server-rendered elements
   - Client nhận serialized data, không re-render

3. ✅ Performance Optimization  
   - Tránh re-render unnecessary code trên client
   - Giữ được server-side optimizations (caching, data fetching)

4. ✅ Architecture Benefits
   - Clear separation between server và client logic
   - Minimal JavaScript bundle
   - Better Core Web Vitals
*/